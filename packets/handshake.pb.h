// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: handshake.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_handshake_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_handshake_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace neptune {
namespace packets {
class DS_PublicKey;
class DS_PublicKeyDefaultTypeInternal;
extern DS_PublicKeyDefaultTypeInternal _DS_PublicKey_default_instance_;
class DS_Result;
class DS_ResultDefaultTypeInternal;
extern DS_ResultDefaultTypeInternal _DS_Result_default_instance_;
class Handshake;
class HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class KEM_PublicKey;
class KEM_PublicKeyDefaultTypeInternal;
extern KEM_PublicKeyDefaultTypeInternal _KEM_PublicKey_default_instance_;
}  // namespace packets
}  // namespace neptune
PROTOBUF_NAMESPACE_OPEN
template<> ::neptune::packets::DS_PublicKey* Arena::CreateMaybeMessage<::neptune::packets::DS_PublicKey>(Arena*);
template<> ::neptune::packets::DS_Result* Arena::CreateMaybeMessage<::neptune::packets::DS_Result>(Arena*);
template<> ::neptune::packets::Handshake* Arena::CreateMaybeMessage<::neptune::packets::Handshake>(Arena*);
template<> ::neptune::packets::KEM_PublicKey* Arena::CreateMaybeMessage<::neptune::packets::KEM_PublicKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace neptune {
namespace packets {

enum E_DS : int {
  _INVALID_DS_ = 0,
  ED25519 = 1,
  ED448 = 2,
  DILITHIUM_1024x768 = 3,
  DILITHIUM_1280x1024 = 4,
  DILITHIUM_1536x1280 = 5,
  FALCON_512 = 6,
  FALCON_1024 = 7,
  E_DS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  E_DS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool E_DS_IsValid(int value);
constexpr E_DS E_DS_MIN = _INVALID_DS_;
constexpr E_DS E_DS_MAX = FALCON_1024;
constexpr int E_DS_ARRAYSIZE = E_DS_MAX + 1;

const std::string& E_DS_Name(E_DS value);
template<typename T>
inline const std::string& E_DS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_DS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_DS_Name.");
  return E_DS_Name(static_cast<E_DS>(enum_t_value));
}
bool E_DS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_DS* value);
enum E_DS_HASH : int {
  _INVALID_DS_HASH_ = 0,
  SHA2_256 = 1,
  SHA3_256 = 4,
  BLAKE3_256 = 7,
  E_DS_HASH_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  E_DS_HASH_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool E_DS_HASH_IsValid(int value);
constexpr E_DS_HASH E_DS_HASH_MIN = _INVALID_DS_HASH_;
constexpr E_DS_HASH E_DS_HASH_MAX = BLAKE3_256;
constexpr int E_DS_HASH_ARRAYSIZE = E_DS_HASH_MAX + 1;

const std::string& E_DS_HASH_Name(E_DS_HASH value);
template<typename T>
inline const std::string& E_DS_HASH_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_DS_HASH>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_DS_HASH_Name.");
  return E_DS_HASH_Name(static_cast<E_DS_HASH>(enum_t_value));
}
bool E_DS_HASH_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_DS_HASH* value);
enum E_KEM : int {
  _INVALID_KEM_ = 0,
  X25519 = 1,
  X448 = 2,
  KYBER_512 = 3,
  KYBER_768 = 4,
  KYBER_1024 = 5,
  KYBER_512_90s = 6,
  KYBER_768_90s = 7,
  KYBER_1024_90s = 8,
  LightSABER = 9,
  SABER = 10,
  FireSABER = 11,
  NTRU = 12,
  E_KEM_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  E_KEM_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool E_KEM_IsValid(int value);
constexpr E_KEM E_KEM_MIN = _INVALID_KEM_;
constexpr E_KEM E_KEM_MAX = NTRU;
constexpr int E_KEM_ARRAYSIZE = E_KEM_MAX + 1;

const std::string& E_KEM_Name(E_KEM value);
template<typename T>
inline const std::string& E_KEM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E_KEM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E_KEM_Name.");
  return E_KEM_Name(static_cast<E_KEM>(enum_t_value));
}
bool E_KEM_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E_KEM* value);
// ===================================================================

class DS_PublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.DS_PublicKey) */ {
 public:
  inline DS_PublicKey() : DS_PublicKey(nullptr) {}
  virtual ~DS_PublicKey();

  DS_PublicKey(const DS_PublicKey& from);
  DS_PublicKey(DS_PublicKey&& from) noexcept
    : DS_PublicKey() {
    *this = ::std::move(from);
  }

  inline DS_PublicKey& operator=(const DS_PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DS_PublicKey& operator=(DS_PublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DS_PublicKey& default_instance();

  static inline const DS_PublicKey* internal_default_instance() {
    return reinterpret_cast<const DS_PublicKey*>(
               &_DS_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DS_PublicKey& a, DS_PublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DS_PublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DS_PublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DS_PublicKey* New() const final {
    return CreateMaybeMessage<DS_PublicKey>(nullptr);
  }

  DS_PublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DS_PublicKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DS_PublicKey& from);
  void MergeFrom(const DS_PublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DS_PublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.DS_PublicKey";
  }
  protected:
  explicit DS_PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .neptune.packets.E_DS type = 1;
  void clear_type();
  ::neptune::packets::E_DS type() const;
  void set_type(::neptune::packets::E_DS value);
  private:
  ::neptune::packets::E_DS _internal_type() const;
  void _internal_set_type(::neptune::packets::E_DS value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.DS_PublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class DS_Result PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.DS_Result) */ {
 public:
  inline DS_Result() : DS_Result(nullptr) {}
  virtual ~DS_Result();

  DS_Result(const DS_Result& from);
  DS_Result(DS_Result&& from) noexcept
    : DS_Result() {
    *this = ::std::move(from);
  }

  inline DS_Result& operator=(const DS_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline DS_Result& operator=(DS_Result&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DS_Result& default_instance();

  static inline const DS_Result* internal_default_instance() {
    return reinterpret_cast<const DS_Result*>(
               &_DS_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DS_Result& a, DS_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(DS_Result* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DS_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DS_Result* New() const final {
    return CreateMaybeMessage<DS_Result>(nullptr);
  }

  DS_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DS_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DS_Result& from);
  void MergeFrom(const DS_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DS_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.DS_Result";
  }
  protected:
  explicit DS_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes result = 2;
  void clear_result();
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .neptune.packets.E_DS type = 1;
  void clear_type();
  ::neptune::packets::E_DS type() const;
  void set_type(::neptune::packets::E_DS value);
  private:
  ::neptune::packets::E_DS _internal_type() const;
  void _internal_set_type(::neptune::packets::E_DS value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.DS_Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class KEM_PublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.KEM_PublicKey) */ {
 public:
  inline KEM_PublicKey() : KEM_PublicKey(nullptr) {}
  virtual ~KEM_PublicKey();

  KEM_PublicKey(const KEM_PublicKey& from);
  KEM_PublicKey(KEM_PublicKey&& from) noexcept
    : KEM_PublicKey() {
    *this = ::std::move(from);
  }

  inline KEM_PublicKey& operator=(const KEM_PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline KEM_PublicKey& operator=(KEM_PublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KEM_PublicKey& default_instance();

  static inline const KEM_PublicKey* internal_default_instance() {
    return reinterpret_cast<const KEM_PublicKey*>(
               &_KEM_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KEM_PublicKey& a, KEM_PublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(KEM_PublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KEM_PublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KEM_PublicKey* New() const final {
    return CreateMaybeMessage<KEM_PublicKey>(nullptr);
  }

  KEM_PublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KEM_PublicKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KEM_PublicKey& from);
  void MergeFrom(const KEM_PublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KEM_PublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.KEM_PublicKey";
  }
  protected:
  explicit KEM_PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .neptune.packets.E_KEM type = 1;
  void clear_type();
  ::neptune::packets::E_KEM type() const;
  void set_type(::neptune::packets::E_KEM value);
  private:
  ::neptune::packets::E_KEM _internal_type() const;
  void _internal_set_type(::neptune::packets::E_KEM value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.KEM_PublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class Handshake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  virtual ~Handshake();

  Handshake(const Handshake& from);
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Handshake& default_instance();

  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }
  inline void Swap(Handshake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Handshake* New() const final {
    return CreateMaybeMessage<Handshake>(nullptr);
  }

  Handshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Handshake& from);
  void MergeFrom(const Handshake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Handshake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.Handshake";
  }
  protected:
  explicit Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKemKeysFieldNumber = 2,
    kDsKeysFieldNumber = 3,
    kDsResultsFieldNumber = 4,
    kSaltFieldNumber = 5,
    kVersionFieldNumber = 1,
  };
  // repeated .neptune.packets.KEM_PublicKey kem_keys = 2;
  int kem_keys_size() const;
  private:
  int _internal_kem_keys_size() const;
  public:
  void clear_kem_keys();
  ::neptune::packets::KEM_PublicKey* mutable_kem_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEM_PublicKey >*
      mutable_kem_keys();
  private:
  const ::neptune::packets::KEM_PublicKey& _internal_kem_keys(int index) const;
  ::neptune::packets::KEM_PublicKey* _internal_add_kem_keys();
  public:
  const ::neptune::packets::KEM_PublicKey& kem_keys(int index) const;
  ::neptune::packets::KEM_PublicKey* add_kem_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEM_PublicKey >&
      kem_keys() const;

  // repeated .neptune.packets.DS_PublicKey ds_keys = 3;
  int ds_keys_size() const;
  private:
  int _internal_ds_keys_size() const;
  public:
  void clear_ds_keys();
  ::neptune::packets::DS_PublicKey* mutable_ds_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_PublicKey >*
      mutable_ds_keys();
  private:
  const ::neptune::packets::DS_PublicKey& _internal_ds_keys(int index) const;
  ::neptune::packets::DS_PublicKey* _internal_add_ds_keys();
  public:
  const ::neptune::packets::DS_PublicKey& ds_keys(int index) const;
  ::neptune::packets::DS_PublicKey* add_ds_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_PublicKey >&
      ds_keys() const;

  // repeated .neptune.packets.DS_Result ds_results = 4;
  int ds_results_size() const;
  private:
  int _internal_ds_results_size() const;
  public:
  void clear_ds_results();
  ::neptune::packets::DS_Result* mutable_ds_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_Result >*
      mutable_ds_results();
  private:
  const ::neptune::packets::DS_Result& _internal_ds_results(int index) const;
  ::neptune::packets::DS_Result* _internal_add_ds_results();
  public:
  const ::neptune::packets::DS_Result& ds_results(int index) const;
  ::neptune::packets::DS_Result* add_ds_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_Result >&
      ds_results() const;

  // bytes salt = 5;
  void clear_salt();
  const std::string& salt() const;
  void set_salt(const std::string& value);
  void set_salt(std::string&& value);
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  std::string* mutable_salt();
  std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // uint32 version = 1;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.Handshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEM_PublicKey > kem_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_PublicKey > ds_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_Result > ds_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DS_PublicKey

// .neptune.packets.E_DS type = 1;
inline void DS_PublicKey::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::E_DS DS_PublicKey::_internal_type() const {
  return static_cast< ::neptune::packets::E_DS >(type_);
}
inline ::neptune::packets::E_DS DS_PublicKey::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DS_PublicKey.type)
  return _internal_type();
}
inline void DS_PublicKey::_internal_set_type(::neptune::packets::E_DS value) {
  
  type_ = value;
}
inline void DS_PublicKey::set_type(::neptune::packets::E_DS value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DS_PublicKey.type)
}

// bytes key = 2;
inline void DS_PublicKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& DS_PublicKey::key() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DS_PublicKey.key)
  return _internal_key();
}
inline void DS_PublicKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DS_PublicKey.key)
}
inline std::string* DS_PublicKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.DS_PublicKey.key)
  return _internal_mutable_key();
}
inline const std::string& DS_PublicKey::_internal_key() const {
  return key_.Get();
}
inline void DS_PublicKey::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DS_PublicKey::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.DS_PublicKey.key)
}
inline void DS_PublicKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.DS_PublicKey.key)
}
inline void DS_PublicKey::set_key(const void* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.DS_PublicKey.key)
}
inline std::string* DS_PublicKey::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DS_PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:neptune.packets.DS_PublicKey.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DS_PublicKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.DS_PublicKey.key)
}

// -------------------------------------------------------------------

// DS_Result

// .neptune.packets.E_DS type = 1;
inline void DS_Result::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::E_DS DS_Result::_internal_type() const {
  return static_cast< ::neptune::packets::E_DS >(type_);
}
inline ::neptune::packets::E_DS DS_Result::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DS_Result.type)
  return _internal_type();
}
inline void DS_Result::_internal_set_type(::neptune::packets::E_DS value) {
  
  type_ = value;
}
inline void DS_Result::set_type(::neptune::packets::E_DS value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DS_Result.type)
}

// bytes result = 2;
inline void DS_Result::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& DS_Result::result() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DS_Result.result)
  return _internal_result();
}
inline void DS_Result::set_result(const std::string& value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DS_Result.result)
}
inline std::string* DS_Result::mutable_result() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.DS_Result.result)
  return _internal_mutable_result();
}
inline const std::string& DS_Result::_internal_result() const {
  return result_.Get();
}
inline void DS_Result::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DS_Result::set_result(std::string&& value) {
  
  result_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.DS_Result.result)
}
inline void DS_Result::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.DS_Result.result)
}
inline void DS_Result::set_result(const void* value,
    size_t size) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.DS_Result.result)
}
inline std::string* DS_Result::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DS_Result::release_result() {
  // @@protoc_insertion_point(field_release:neptune.packets.DS_Result.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DS_Result::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.DS_Result.result)
}

// -------------------------------------------------------------------

// KEM_PublicKey

// .neptune.packets.E_KEM type = 1;
inline void KEM_PublicKey::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::E_KEM KEM_PublicKey::_internal_type() const {
  return static_cast< ::neptune::packets::E_KEM >(type_);
}
inline ::neptune::packets::E_KEM KEM_PublicKey::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.KEM_PublicKey.type)
  return _internal_type();
}
inline void KEM_PublicKey::_internal_set_type(::neptune::packets::E_KEM value) {
  
  type_ = value;
}
inline void KEM_PublicKey::set_type(::neptune::packets::E_KEM value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.KEM_PublicKey.type)
}

// bytes key = 2;
inline void KEM_PublicKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KEM_PublicKey::key() const {
  // @@protoc_insertion_point(field_get:neptune.packets.KEM_PublicKey.key)
  return _internal_key();
}
inline void KEM_PublicKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:neptune.packets.KEM_PublicKey.key)
}
inline std::string* KEM_PublicKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.KEM_PublicKey.key)
  return _internal_mutable_key();
}
inline const std::string& KEM_PublicKey::_internal_key() const {
  return key_.Get();
}
inline void KEM_PublicKey::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void KEM_PublicKey::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.KEM_PublicKey.key)
}
inline void KEM_PublicKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.KEM_PublicKey.key)
}
inline void KEM_PublicKey::set_key(const void* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.KEM_PublicKey.key)
}
inline std::string* KEM_PublicKey::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* KEM_PublicKey::release_key() {
  // @@protoc_insertion_point(field_release:neptune.packets.KEM_PublicKey.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KEM_PublicKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.KEM_PublicKey.key)
}

// -------------------------------------------------------------------

// Handshake

// uint32 version = 1;
inline void Handshake::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Handshake::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Handshake::version() const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.version)
  return _internal_version();
}
inline void Handshake::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void Handshake::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:neptune.packets.Handshake.version)
}

// repeated .neptune.packets.KEM_PublicKey kem_keys = 2;
inline int Handshake::_internal_kem_keys_size() const {
  return kem_keys_.size();
}
inline int Handshake::kem_keys_size() const {
  return _internal_kem_keys_size();
}
inline void Handshake::clear_kem_keys() {
  kem_keys_.Clear();
}
inline ::neptune::packets::KEM_PublicKey* Handshake::mutable_kem_keys(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.kem_keys)
  return kem_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEM_PublicKey >*
Handshake::mutable_kem_keys() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.kem_keys)
  return &kem_keys_;
}
inline const ::neptune::packets::KEM_PublicKey& Handshake::_internal_kem_keys(int index) const {
  return kem_keys_.Get(index);
}
inline const ::neptune::packets::KEM_PublicKey& Handshake::kem_keys(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.kem_keys)
  return _internal_kem_keys(index);
}
inline ::neptune::packets::KEM_PublicKey* Handshake::_internal_add_kem_keys() {
  return kem_keys_.Add();
}
inline ::neptune::packets::KEM_PublicKey* Handshake::add_kem_keys() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.kem_keys)
  return _internal_add_kem_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEM_PublicKey >&
Handshake::kem_keys() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.kem_keys)
  return kem_keys_;
}

// repeated .neptune.packets.DS_PublicKey ds_keys = 3;
inline int Handshake::_internal_ds_keys_size() const {
  return ds_keys_.size();
}
inline int Handshake::ds_keys_size() const {
  return _internal_ds_keys_size();
}
inline void Handshake::clear_ds_keys() {
  ds_keys_.Clear();
}
inline ::neptune::packets::DS_PublicKey* Handshake::mutable_ds_keys(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.ds_keys)
  return ds_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_PublicKey >*
Handshake::mutable_ds_keys() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.ds_keys)
  return &ds_keys_;
}
inline const ::neptune::packets::DS_PublicKey& Handshake::_internal_ds_keys(int index) const {
  return ds_keys_.Get(index);
}
inline const ::neptune::packets::DS_PublicKey& Handshake::ds_keys(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.ds_keys)
  return _internal_ds_keys(index);
}
inline ::neptune::packets::DS_PublicKey* Handshake::_internal_add_ds_keys() {
  return ds_keys_.Add();
}
inline ::neptune::packets::DS_PublicKey* Handshake::add_ds_keys() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.ds_keys)
  return _internal_add_ds_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_PublicKey >&
Handshake::ds_keys() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.ds_keys)
  return ds_keys_;
}

// repeated .neptune.packets.DS_Result ds_results = 4;
inline int Handshake::_internal_ds_results_size() const {
  return ds_results_.size();
}
inline int Handshake::ds_results_size() const {
  return _internal_ds_results_size();
}
inline void Handshake::clear_ds_results() {
  ds_results_.Clear();
}
inline ::neptune::packets::DS_Result* Handshake::mutable_ds_results(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.ds_results)
  return ds_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_Result >*
Handshake::mutable_ds_results() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.ds_results)
  return &ds_results_;
}
inline const ::neptune::packets::DS_Result& Handshake::_internal_ds_results(int index) const {
  return ds_results_.Get(index);
}
inline const ::neptune::packets::DS_Result& Handshake::ds_results(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.ds_results)
  return _internal_ds_results(index);
}
inline ::neptune::packets::DS_Result* Handshake::_internal_add_ds_results() {
  return ds_results_.Add();
}
inline ::neptune::packets::DS_Result* Handshake::add_ds_results() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.ds_results)
  return _internal_add_ds_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DS_Result >&
Handshake::ds_results() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.ds_results)
  return ds_results_;
}

// bytes salt = 5;
inline void Handshake::clear_salt() {
  salt_.ClearToEmpty();
}
inline const std::string& Handshake::salt() const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.salt)
  return _internal_salt();
}
inline void Handshake::set_salt(const std::string& value) {
  _internal_set_salt(value);
  // @@protoc_insertion_point(field_set:neptune.packets.Handshake.salt)
}
inline std::string* Handshake::mutable_salt() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.salt)
  return _internal_mutable_salt();
}
inline const std::string& Handshake::_internal_salt() const {
  return salt_.Get();
}
inline void Handshake::_internal_set_salt(const std::string& value) {
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Handshake::set_salt(std::string&& value) {
  
  salt_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.Handshake.salt)
}
inline void Handshake::set_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.Handshake.salt)
}
inline void Handshake::set_salt(const void* value,
    size_t size) {
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.Handshake.salt)
}
inline std::string* Handshake::_internal_mutable_salt() {
  
  return salt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Handshake::release_salt() {
  // @@protoc_insertion_point(field_release:neptune.packets.Handshake.salt)
  return salt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Handshake::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  salt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), salt,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.Handshake.salt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace neptune

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::neptune::packets::E_DS> : ::std::true_type {};
template <> struct is_proto_enum< ::neptune::packets::E_DS_HASH> : ::std::true_type {};
template <> struct is_proto_enum< ::neptune::packets::E_KEM> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto
