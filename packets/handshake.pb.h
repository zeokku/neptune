// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: handshake.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_handshake_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_handshake_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace neptune {
namespace packets {
class DSPublicKey;
class DSPublicKeyDefaultTypeInternal;
extern DSPublicKeyDefaultTypeInternal _DSPublicKey_default_instance_;
class DSResult;
class DSResultDefaultTypeInternal;
extern DSResultDefaultTypeInternal _DSResult_default_instance_;
class Handshake;
class HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class KEMPublicKey;
class KEMPublicKeyDefaultTypeInternal;
extern KEMPublicKeyDefaultTypeInternal _KEMPublicKey_default_instance_;
}  // namespace packets
}  // namespace neptune
PROTOBUF_NAMESPACE_OPEN
template<> ::neptune::packets::DSPublicKey* Arena::CreateMaybeMessage<::neptune::packets::DSPublicKey>(Arena*);
template<> ::neptune::packets::DSResult* Arena::CreateMaybeMessage<::neptune::packets::DSResult>(Arena*);
template<> ::neptune::packets::Handshake* Arena::CreateMaybeMessage<::neptune::packets::Handshake>(Arena*);
template<> ::neptune::packets::KEMPublicKey* Arena::CreateMaybeMessage<::neptune::packets::KEMPublicKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace neptune {
namespace packets {

enum eDS : int {
  _INVALID_DS_ = 0,
  ED25519 = 1,
  ED448 = 2,
  DILITHIUM_1024x768 = 3,
  DILITHIUM_1280x1024 = 4,
  DILITHIUM_1536x1280 = 5,
  FALCON_512 = 6,
  FALCON_1024 = 7,
  eDS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eDS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eDS_IsValid(int value);
constexpr eDS eDS_MIN = _INVALID_DS_;
constexpr eDS eDS_MAX = FALCON_1024;
constexpr int eDS_ARRAYSIZE = eDS_MAX + 1;

const std::string& eDS_Name(eDS value);
template<typename T>
inline const std::string& eDS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eDS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eDS_Name.");
  return eDS_Name(static_cast<eDS>(enum_t_value));
}
bool eDS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, eDS* value);
enum eHashing : int {
  _INVALID_H_ = 0,
  SHA2_256 = 1,
  SHA3_256 = 4,
  BLAKE3_256 = 7,
  eHashing_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eHashing_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eHashing_IsValid(int value);
constexpr eHashing eHashing_MIN = _INVALID_H_;
constexpr eHashing eHashing_MAX = BLAKE3_256;
constexpr int eHashing_ARRAYSIZE = eHashing_MAX + 1;

const std::string& eHashing_Name(eHashing value);
template<typename T>
inline const std::string& eHashing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eHashing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eHashing_Name.");
  return eHashing_Name(static_cast<eHashing>(enum_t_value));
}
bool eHashing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, eHashing* value);
enum eKEM : int {
  _INVALID_KEM_ = 0,
  X25519 = 1,
  X448 = 2,
  KYBER_512 = 3,
  KYBER_768 = 4,
  KYBER_1024 = 5,
  KYBER_512_90s = 6,
  KYBER_768_90s = 7,
  KYBER_1024_90s = 8,
  LightSABER = 9,
  SABER = 10,
  FireSABER = 11,
  NTRU = 12,
  eKEM_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eKEM_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eKEM_IsValid(int value);
constexpr eKEM eKEM_MIN = _INVALID_KEM_;
constexpr eKEM eKEM_MAX = NTRU;
constexpr int eKEM_ARRAYSIZE = eKEM_MAX + 1;

const std::string& eKEM_Name(eKEM value);
template<typename T>
inline const std::string& eKEM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eKEM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eKEM_Name.");
  return eKEM_Name(static_cast<eKEM>(enum_t_value));
}
bool eKEM_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, eKEM* value);
// ===================================================================

class DSPublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.DSPublicKey) */ {
 public:
  inline DSPublicKey() : DSPublicKey(nullptr) {}
  virtual ~DSPublicKey();

  DSPublicKey(const DSPublicKey& from);
  DSPublicKey(DSPublicKey&& from) noexcept
    : DSPublicKey() {
    *this = ::std::move(from);
  }

  inline DSPublicKey& operator=(const DSPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DSPublicKey& operator=(DSPublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DSPublicKey& default_instance();

  static inline const DSPublicKey* internal_default_instance() {
    return reinterpret_cast<const DSPublicKey*>(
               &_DSPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DSPublicKey& a, DSPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DSPublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DSPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DSPublicKey* New() const final {
    return CreateMaybeMessage<DSPublicKey>(nullptr);
  }

  DSPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DSPublicKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DSPublicKey& from);
  void MergeFrom(const DSPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DSPublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.DSPublicKey";
  }
  protected:
  explicit DSPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .neptune.packets.eDS type = 1;
  void clear_type();
  ::neptune::packets::eDS type() const;
  void set_type(::neptune::packets::eDS value);
  private:
  ::neptune::packets::eDS _internal_type() const;
  void _internal_set_type(::neptune::packets::eDS value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.DSPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class DSResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.DSResult) */ {
 public:
  inline DSResult() : DSResult(nullptr) {}
  virtual ~DSResult();

  DSResult(const DSResult& from);
  DSResult(DSResult&& from) noexcept
    : DSResult() {
    *this = ::std::move(from);
  }

  inline DSResult& operator=(const DSResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DSResult& operator=(DSResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DSResult& default_instance();

  static inline const DSResult* internal_default_instance() {
    return reinterpret_cast<const DSResult*>(
               &_DSResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DSResult& a, DSResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DSResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DSResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DSResult* New() const final {
    return CreateMaybeMessage<DSResult>(nullptr);
  }

  DSResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DSResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DSResult& from);
  void MergeFrom(const DSResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DSResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.DSResult";
  }
  protected:
  explicit DSResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes result = 2;
  void clear_result();
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .neptune.packets.eDS type = 1;
  void clear_type();
  ::neptune::packets::eDS type() const;
  void set_type(::neptune::packets::eDS value);
  private:
  ::neptune::packets::eDS _internal_type() const;
  void _internal_set_type(::neptune::packets::eDS value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.DSResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class KEMPublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.KEMPublicKey) */ {
 public:
  inline KEMPublicKey() : KEMPublicKey(nullptr) {}
  virtual ~KEMPublicKey();

  KEMPublicKey(const KEMPublicKey& from);
  KEMPublicKey(KEMPublicKey&& from) noexcept
    : KEMPublicKey() {
    *this = ::std::move(from);
  }

  inline KEMPublicKey& operator=(const KEMPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline KEMPublicKey& operator=(KEMPublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KEMPublicKey& default_instance();

  static inline const KEMPublicKey* internal_default_instance() {
    return reinterpret_cast<const KEMPublicKey*>(
               &_KEMPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KEMPublicKey& a, KEMPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(KEMPublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KEMPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KEMPublicKey* New() const final {
    return CreateMaybeMessage<KEMPublicKey>(nullptr);
  }

  KEMPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KEMPublicKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const KEMPublicKey& from);
  void MergeFrom(const KEMPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KEMPublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.KEMPublicKey";
  }
  protected:
  explicit KEMPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .neptune.packets.eKEM type = 1;
  void clear_type();
  ::neptune::packets::eKEM type() const;
  void set_type(::neptune::packets::eKEM value);
  private:
  ::neptune::packets::eKEM _internal_type() const;
  void _internal_set_type(::neptune::packets::eKEM value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.KEMPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// -------------------------------------------------------------------

class Handshake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:neptune.packets.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  virtual ~Handshake();

  Handshake(const Handshake& from);
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Handshake& default_instance();

  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }
  inline void Swap(Handshake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Handshake* New() const final {
    return CreateMaybeMessage<Handshake>(nullptr);
  }

  Handshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Handshake& from);
  void MergeFrom(const Handshake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Handshake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "neptune.packets.Handshake";
  }
  protected:
  explicit Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKemKeysFieldNumber = 2,
    kDsKeysFieldNumber = 3,
    kDsResultsFieldNumber = 4,
    kSaltFieldNumber = 5,
    kVersionFieldNumber = 1,
  };
  // repeated .neptune.packets.KEMPublicKey kem_keys = 2;
  int kem_keys_size() const;
  private:
  int _internal_kem_keys_size() const;
  public:
  void clear_kem_keys();
  ::neptune::packets::KEMPublicKey* mutable_kem_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEMPublicKey >*
      mutable_kem_keys();
  private:
  const ::neptune::packets::KEMPublicKey& _internal_kem_keys(int index) const;
  ::neptune::packets::KEMPublicKey* _internal_add_kem_keys();
  public:
  const ::neptune::packets::KEMPublicKey& kem_keys(int index) const;
  ::neptune::packets::KEMPublicKey* add_kem_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEMPublicKey >&
      kem_keys() const;

  // repeated .neptune.packets.DSPublicKey ds_keys = 3;
  int ds_keys_size() const;
  private:
  int _internal_ds_keys_size() const;
  public:
  void clear_ds_keys();
  ::neptune::packets::DSPublicKey* mutable_ds_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSPublicKey >*
      mutable_ds_keys();
  private:
  const ::neptune::packets::DSPublicKey& _internal_ds_keys(int index) const;
  ::neptune::packets::DSPublicKey* _internal_add_ds_keys();
  public:
  const ::neptune::packets::DSPublicKey& ds_keys(int index) const;
  ::neptune::packets::DSPublicKey* add_ds_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSPublicKey >&
      ds_keys() const;

  // repeated .neptune.packets.DSResult ds_results = 4;
  int ds_results_size() const;
  private:
  int _internal_ds_results_size() const;
  public:
  void clear_ds_results();
  ::neptune::packets::DSResult* mutable_ds_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSResult >*
      mutable_ds_results();
  private:
  const ::neptune::packets::DSResult& _internal_ds_results(int index) const;
  ::neptune::packets::DSResult* _internal_add_ds_results();
  public:
  const ::neptune::packets::DSResult& ds_results(int index) const;
  ::neptune::packets::DSResult* add_ds_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSResult >&
      ds_results() const;

  // bytes salt = 5;
  void clear_salt();
  const std::string& salt() const;
  void set_salt(const std::string& value);
  void set_salt(std::string&& value);
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  std::string* mutable_salt();
  std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // uint32 version = 1;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:neptune.packets.Handshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEMPublicKey > kem_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSPublicKey > ds_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSResult > ds_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_handshake_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DSPublicKey

// .neptune.packets.eDS type = 1;
inline void DSPublicKey::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::eDS DSPublicKey::_internal_type() const {
  return static_cast< ::neptune::packets::eDS >(type_);
}
inline ::neptune::packets::eDS DSPublicKey::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DSPublicKey.type)
  return _internal_type();
}
inline void DSPublicKey::_internal_set_type(::neptune::packets::eDS value) {
  
  type_ = value;
}
inline void DSPublicKey::set_type(::neptune::packets::eDS value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DSPublicKey.type)
}

// bytes key = 2;
inline void DSPublicKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& DSPublicKey::key() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DSPublicKey.key)
  return _internal_key();
}
inline void DSPublicKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DSPublicKey.key)
}
inline std::string* DSPublicKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.DSPublicKey.key)
  return _internal_mutable_key();
}
inline const std::string& DSPublicKey::_internal_key() const {
  return key_.Get();
}
inline void DSPublicKey::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DSPublicKey::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.DSPublicKey.key)
}
inline void DSPublicKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.DSPublicKey.key)
}
inline void DSPublicKey::set_key(const void* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.DSPublicKey.key)
}
inline std::string* DSPublicKey::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DSPublicKey::release_key() {
  // @@protoc_insertion_point(field_release:neptune.packets.DSPublicKey.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DSPublicKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.DSPublicKey.key)
}

// -------------------------------------------------------------------

// DSResult

// .neptune.packets.eDS type = 1;
inline void DSResult::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::eDS DSResult::_internal_type() const {
  return static_cast< ::neptune::packets::eDS >(type_);
}
inline ::neptune::packets::eDS DSResult::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DSResult.type)
  return _internal_type();
}
inline void DSResult::_internal_set_type(::neptune::packets::eDS value) {
  
  type_ = value;
}
inline void DSResult::set_type(::neptune::packets::eDS value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DSResult.type)
}

// bytes result = 2;
inline void DSResult::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& DSResult::result() const {
  // @@protoc_insertion_point(field_get:neptune.packets.DSResult.result)
  return _internal_result();
}
inline void DSResult::set_result(const std::string& value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:neptune.packets.DSResult.result)
}
inline std::string* DSResult::mutable_result() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.DSResult.result)
  return _internal_mutable_result();
}
inline const std::string& DSResult::_internal_result() const {
  return result_.Get();
}
inline void DSResult::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DSResult::set_result(std::string&& value) {
  
  result_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.DSResult.result)
}
inline void DSResult::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.DSResult.result)
}
inline void DSResult::set_result(const void* value,
    size_t size) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.DSResult.result)
}
inline std::string* DSResult::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DSResult::release_result() {
  // @@protoc_insertion_point(field_release:neptune.packets.DSResult.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DSResult::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.DSResult.result)
}

// -------------------------------------------------------------------

// KEMPublicKey

// .neptune.packets.eKEM type = 1;
inline void KEMPublicKey::clear_type() {
  type_ = 0;
}
inline ::neptune::packets::eKEM KEMPublicKey::_internal_type() const {
  return static_cast< ::neptune::packets::eKEM >(type_);
}
inline ::neptune::packets::eKEM KEMPublicKey::type() const {
  // @@protoc_insertion_point(field_get:neptune.packets.KEMPublicKey.type)
  return _internal_type();
}
inline void KEMPublicKey::_internal_set_type(::neptune::packets::eKEM value) {
  
  type_ = value;
}
inline void KEMPublicKey::set_type(::neptune::packets::eKEM value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:neptune.packets.KEMPublicKey.type)
}

// bytes key = 2;
inline void KEMPublicKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KEMPublicKey::key() const {
  // @@protoc_insertion_point(field_get:neptune.packets.KEMPublicKey.key)
  return _internal_key();
}
inline void KEMPublicKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:neptune.packets.KEMPublicKey.key)
}
inline std::string* KEMPublicKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.KEMPublicKey.key)
  return _internal_mutable_key();
}
inline const std::string& KEMPublicKey::_internal_key() const {
  return key_.Get();
}
inline void KEMPublicKey::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void KEMPublicKey::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.KEMPublicKey.key)
}
inline void KEMPublicKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.KEMPublicKey.key)
}
inline void KEMPublicKey::set_key(const void* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.KEMPublicKey.key)
}
inline std::string* KEMPublicKey::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* KEMPublicKey::release_key() {
  // @@protoc_insertion_point(field_release:neptune.packets.KEMPublicKey.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KEMPublicKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.KEMPublicKey.key)
}

// -------------------------------------------------------------------

// Handshake

// uint32 version = 1;
inline void Handshake::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Handshake::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Handshake::version() const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.version)
  return _internal_version();
}
inline void Handshake::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void Handshake::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:neptune.packets.Handshake.version)
}

// repeated .neptune.packets.KEMPublicKey kem_keys = 2;
inline int Handshake::_internal_kem_keys_size() const {
  return kem_keys_.size();
}
inline int Handshake::kem_keys_size() const {
  return _internal_kem_keys_size();
}
inline void Handshake::clear_kem_keys() {
  kem_keys_.Clear();
}
inline ::neptune::packets::KEMPublicKey* Handshake::mutable_kem_keys(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.kem_keys)
  return kem_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEMPublicKey >*
Handshake::mutable_kem_keys() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.kem_keys)
  return &kem_keys_;
}
inline const ::neptune::packets::KEMPublicKey& Handshake::_internal_kem_keys(int index) const {
  return kem_keys_.Get(index);
}
inline const ::neptune::packets::KEMPublicKey& Handshake::kem_keys(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.kem_keys)
  return _internal_kem_keys(index);
}
inline ::neptune::packets::KEMPublicKey* Handshake::_internal_add_kem_keys() {
  return kem_keys_.Add();
}
inline ::neptune::packets::KEMPublicKey* Handshake::add_kem_keys() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.kem_keys)
  return _internal_add_kem_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::KEMPublicKey >&
Handshake::kem_keys() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.kem_keys)
  return kem_keys_;
}

// repeated .neptune.packets.DSPublicKey ds_keys = 3;
inline int Handshake::_internal_ds_keys_size() const {
  return ds_keys_.size();
}
inline int Handshake::ds_keys_size() const {
  return _internal_ds_keys_size();
}
inline void Handshake::clear_ds_keys() {
  ds_keys_.Clear();
}
inline ::neptune::packets::DSPublicKey* Handshake::mutable_ds_keys(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.ds_keys)
  return ds_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSPublicKey >*
Handshake::mutable_ds_keys() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.ds_keys)
  return &ds_keys_;
}
inline const ::neptune::packets::DSPublicKey& Handshake::_internal_ds_keys(int index) const {
  return ds_keys_.Get(index);
}
inline const ::neptune::packets::DSPublicKey& Handshake::ds_keys(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.ds_keys)
  return _internal_ds_keys(index);
}
inline ::neptune::packets::DSPublicKey* Handshake::_internal_add_ds_keys() {
  return ds_keys_.Add();
}
inline ::neptune::packets::DSPublicKey* Handshake::add_ds_keys() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.ds_keys)
  return _internal_add_ds_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSPublicKey >&
Handshake::ds_keys() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.ds_keys)
  return ds_keys_;
}

// repeated .neptune.packets.DSResult ds_results = 4;
inline int Handshake::_internal_ds_results_size() const {
  return ds_results_.size();
}
inline int Handshake::ds_results_size() const {
  return _internal_ds_results_size();
}
inline void Handshake::clear_ds_results() {
  ds_results_.Clear();
}
inline ::neptune::packets::DSResult* Handshake::mutable_ds_results(int index) {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.ds_results)
  return ds_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSResult >*
Handshake::mutable_ds_results() {
  // @@protoc_insertion_point(field_mutable_list:neptune.packets.Handshake.ds_results)
  return &ds_results_;
}
inline const ::neptune::packets::DSResult& Handshake::_internal_ds_results(int index) const {
  return ds_results_.Get(index);
}
inline const ::neptune::packets::DSResult& Handshake::ds_results(int index) const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.ds_results)
  return _internal_ds_results(index);
}
inline ::neptune::packets::DSResult* Handshake::_internal_add_ds_results() {
  return ds_results_.Add();
}
inline ::neptune::packets::DSResult* Handshake::add_ds_results() {
  // @@protoc_insertion_point(field_add:neptune.packets.Handshake.ds_results)
  return _internal_add_ds_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::neptune::packets::DSResult >&
Handshake::ds_results() const {
  // @@protoc_insertion_point(field_list:neptune.packets.Handshake.ds_results)
  return ds_results_;
}

// bytes salt = 5;
inline void Handshake::clear_salt() {
  salt_.ClearToEmpty();
}
inline const std::string& Handshake::salt() const {
  // @@protoc_insertion_point(field_get:neptune.packets.Handshake.salt)
  return _internal_salt();
}
inline void Handshake::set_salt(const std::string& value) {
  _internal_set_salt(value);
  // @@protoc_insertion_point(field_set:neptune.packets.Handshake.salt)
}
inline std::string* Handshake::mutable_salt() {
  // @@protoc_insertion_point(field_mutable:neptune.packets.Handshake.salt)
  return _internal_mutable_salt();
}
inline const std::string& Handshake::_internal_salt() const {
  return salt_.Get();
}
inline void Handshake::_internal_set_salt(const std::string& value) {
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Handshake::set_salt(std::string&& value) {
  
  salt_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:neptune.packets.Handshake.salt)
}
inline void Handshake::set_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:neptune.packets.Handshake.salt)
}
inline void Handshake::set_salt(const void* value,
    size_t size) {
  
  salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:neptune.packets.Handshake.salt)
}
inline std::string* Handshake::_internal_mutable_salt() {
  
  return salt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Handshake::release_salt() {
  // @@protoc_insertion_point(field_release:neptune.packets.Handshake.salt)
  return salt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Handshake::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  salt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), salt,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:neptune.packets.Handshake.salt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace neptune

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::neptune::packets::eDS> : ::std::true_type {};
template <> struct is_proto_enum< ::neptune::packets::eHashing> : ::std::true_type {};
template <> struct is_proto_enum< ::neptune::packets::eKEM> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_handshake_2eproto
